$date
	Thu Sep 11 16:29:06 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module single_cycle_module_testbech $end
$var reg 1 ! clk $end
$var reg 1 " rst $end
$scope module scm $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 # Result_wire [31:0] $end
$var wire 1 $ ResultSrc_wire $end
$var wire 1 % RegWrite_wire $end
$var wire 32 & ReadData_wire [31:0] $end
$var wire 32 ' RDInstr_wire [31:0] $end
$var wire 32 ( RD2_wire [31:0] $end
$var wire 32 ) RD1_wire [31:0] $end
$var wire 32 * PC_wire [31:0] $end
$var wire 32 + PCPlus4_wire [31:0] $end
$var wire 32 , Mux_ALUSrc_wire [31:0] $end
$var wire 1 - MemWrite_wire $end
$var wire 2 . ImmSrc_wire [1:0] $end
$var wire 32 / ImmExt_wire [31:0] $end
$var wire 1 0 ALUSrc_wire $end
$var wire 32 1 ALUResult_wire [31:0] $end
$var wire 2 2 ALUOp_wire [1:0] $end
$var wire 3 3 ALUControl_wire [2:0] $end
$scope module alu $end
$var wire 32 4 ALUResult [31:0] $end
$var wire 1 5 C $end
$var wire 1 6 V $end
$var wire 32 7 a_and_b [31:0] $end
$var wire 32 8 a_or_b [31:0] $end
$var wire 32 9 not_b [31:0] $end
$var wire 32 : sum [31:0] $end
$var wire 32 ; slt [31:0] $end
$var wire 32 < mux_2 [31:0] $end
$var wire 32 = mux_1 [31:0] $end
$var wire 1 > cout $end
$var wire 1 ? Ze $end
$var wire 1 @ N $end
$var wire 32 A B [31:0] $end
$var wire 3 B ALUControl [2:0] $end
$var wire 32 C A [31:0] $end
$upscope $end
$scope module aludecoder $end
$var wire 3 D funct3 [2:0] $end
$var wire 1 E funct7 $end
$var wire 1 F op $end
$var wire 2 G concatenation [1:0] $end
$var wire 2 H ALUOp [1:0] $end
$var wire 3 I ALUControl [2:0] $end
$upscope $end
$scope module dm $end
$var wire 32 J A [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 1 - WE $end
$var wire 32 K WD [31:0] $end
$var wire 32 L RD [31:0] $end
$upscope $end
$scope module im $end
$var wire 1 " rst $end
$var wire 32 M RD [31:0] $end
$var wire 32 N A [31:0] $end
$upscope $end
$scope module maindecoder $end
$var wire 1 O PSCrc $end
$var wire 7 P op [6:0] $end
$var wire 1 Q zero $end
$var wire 1 R branch $end
$var wire 1 $ ResultSrc $end
$var wire 1 % RegWrite $end
$var wire 1 - MemWrite $end
$var wire 2 S ImmSrc [1:0] $end
$var wire 1 0 ALUSrc $end
$var wire 2 T ALUOp [1:0] $end
$upscope $end
$scope module mux_forALUsrc $end
$var wire 1 0 s $end
$var wire 32 U c [31:0] $end
$var wire 32 V b [31:0] $end
$var wire 32 W a [31:0] $end
$upscope $end
$scope module mux_forDatamem $end
$var wire 32 X a [31:0] $end
$var wire 32 Y b [31:0] $end
$var wire 1 $ s $end
$var wire 32 Z c [31:0] $end
$upscope $end
$scope module pc $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 [ PC_NEXT [31:0] $end
$var reg 32 \ PC [31:0] $end
$upscope $end
$scope module pcaddermodule $end
$var wire 32 ] a [31:0] $end
$var wire 32 ^ b [31:0] $end
$var wire 32 _ c [31:0] $end
$upscope $end
$scope module rf $end
$var wire 5 ` A1 [4:0] $end
$var wire 5 a A2 [4:0] $end
$var wire 5 b A3 [4:0] $end
$var wire 32 c WD3 [31:0] $end
$var wire 1 % WE3 $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 d RD2 [31:0] $end
$var wire 32 e RD1 [31:0] $end
$upscope $end
$scope module se $end
$var wire 2 f ImmSrc [1:0] $end
$var wire 32 g Instr [31:0] $end
$var wire 32 h ImmExt [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 h
b0 g
b0 f
b0 e
b0 d
b0 c
b0 b
b0 a
b0 `
b100 _
b100 ^
b0 ]
b0 \
b100 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b0 U
b0 T
b0 S
0R
zQ
b0 P
0O
b0 N
b0 M
b0 L
b0 K
b0 J
b0 I
b0 H
b0 G
0F
0E
b0 D
b0 C
b0 B
b0 A
0@
1?
0>
b0 =
b0 <
b0 ;
b0 :
b11111111111111111111111111111111 9
b0 8
b0 7
06
05
b0 4
b0 3
b0 2
b0 1
00
b0 /
b0 .
0-
b0 ,
b100 +
b0 *
b0 )
b0 (
b0 '
b0 &
0%
0$
b0 #
0"
0!
$end
#50
1!
#100
b11 3
b11 B
b11 I
1%
06
b110 /
b110 V
b110 h
b10 2
b10 H
b10 T
0@
b1110 #
b1110 Z
b1110 c
b110 D
b10 G
1F
b110011 P
b100 b
b110 a
b101 `
b1 ;
0?
b1110 1
b1110 4
b1110 J
b1110 X
b1110 <
05
b11111111111111111111111111110101 =
b11111111111111111111111111110101 9
bx &
bx L
bx Y
b11000101110001000110011 '
b11000101110001000110011 M
b11000101110001000110011 g
b11111111111111111111111111111100 :
0>
b1110 8
b10 7
b1010 ,
b1010 A
b1010 U
b110 )
b110 C
b110 e
b1010 (
b1010 K
b1010 W
b1010 d
0!
1"
#150
x6
x5
x@
bx =
bx #
bx Z
bx c
x?
bx 1
bx 4
bx J
bx X
bx <
bx 9
b0x ;
x%
x0
xO
bx 3
bx B
bx I
bx ,
bx A
bx U
bx :
x>
bx 8
bx 7
bx /
bx V
bx h
x-
x$
xR
bx .
bx S
bx f
bx 2
bx H
bx T
bx (
bx K
bx W
bx d
bx )
bx C
bx e
xE
bx D
bx G
xF
bx P
bx b
bx a
bx `
bx '
bx M
bx g
b1000 +
b1000 [
b1000 _
b100 *
b100 N
b100 \
b100 ]
1!
#200
0!
#250
b1100 +
b1100 [
b1100 _
b1000 *
b1000 N
b1000 \
b1000 ]
1!
#300
0!
#350
b10000 +
b10000 [
b10000 _
b1100 *
b1100 N
b1100 \
b1100 ]
1!
#400
0!
